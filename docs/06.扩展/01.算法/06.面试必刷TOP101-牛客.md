---
title: 面试必刷TOP101-牛客
index_img: /img/article/empty.png
categories: 
  - 算法
tags: 
  - 牛客
  - 算法
date: 2023-10-30 17:49:31
permalink: /pages/d98a91/
author: 
  name: 爱写bug的小邓程序员
  link: https://github.com/dengerpu
---

## 反转链表

给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。

数据范围： 0≤*n*≤1000

要求：空间复杂度 O(1) ，时间复杂度O(n) 。

如当输入链表{1,2,3}时，

经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。

以上转换过程如下图所示：

![img](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/202310301751436.png)

* 示例1

输入：

```
{1,2,3}
```

返回值：

```
{3,2,1}
```

* 示例2

输入：

```
{}
```

返回值：

```
{}
```

说明：

```
空链表则输出空               
```

### 双指针迭代法

![image-20231030201115024](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/202310302011141.png)

在遍历链表时，将当前节点的next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。

![图片说明](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/202310302012218.gif)

```javascript
function ReverseList( head ) {
    let prev = null;
    let curr =head;
    while(curr != null) {
      let temp = curr.next;
      curr.next = prev;
      prev = curr;
      curr = temp;
    }
    // 最后要返回prev
    return prev;
}
```

### 递归

```javascript
// 解法二： 递归
function ReverseList2( head ) {
  if(head == null || head.next == null) {
    return head
  }
  // 保存当前的下一个节点
  let nextNode = head.next;
  // 递归调用
  // 从当前节点的下一个结点开始递归调用
  let ans = ReverseList2(nextNode);
  //让当前结点的下一个结点的 next 指针指向当前节点
  nextNode.next = head;
  //同时让当前结点的 next 指针指向NULL ，从而实现从链表尾部开始的局部反转
  head.next = null;
  return ans;
} 
```

### 利用栈

先进栈再出栈，由于简单就不写