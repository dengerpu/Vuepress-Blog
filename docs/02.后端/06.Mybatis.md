---
title: Mybatis
tags: 
  - Mybatis
index_img: /img/article/mybatis.png
date: 2022-07-19 11:02:00
categories: 
  - 后端
permalink: /pages/9c8a8c/
author: 
  name: 爱写bug的小邓程序员
  link: https://github.com/dengerpu
---

# Mybatis

官网：https://github.com/mybatis/mybatis-3

## 1.搭建MyBatis

### 1.1创建项目

![image-20220717142355886](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220717142355886.png)

![image-20220717142839109](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220717142839109.png)

设置maven

![image-20220717143006828](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220717143006828.png)

### 1.2创建maven工程

a>打包方式：jar
b>引入依赖

![image-20220717143613255](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220717143613255.png)

![image-20220717143726679](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220717143726679.png)

```xml
    <packaging>jar</packaging>
    <dependencies>
        <!-- Mybatis核心 -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.7</version>
        </dependency>
        <!-- junit测试 -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
        <!-- MySQL驱动 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.3</version>
        </dependency>
    </dependencies>
```

### 1.3创建MyBatis的核心配置文件

> 习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring
> 之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。
> 核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息
>
> 核心配置文件存放的位置是src/main/resources目录下

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!--设置连接数据库的环境-->
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url"
                          value="jdbc:mysql://localhost:3306/mybatis"/>
                <property name="username" value="root"/>
                <property name="password" value="root"/>
            </dataSource>
        </environment>
    </environments>
    <!--引入映射文件-->
    <mappers>
        <mapper resource="mappers/UserMapper.xml"/>
    </mappers>
</configuration>
```

### 1.4创建mapper接口

> MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类。

### 1.5创建MyBatis的映射文件

相关概念：ORM（Object Relationship Mapping）对象关系映射。
对象：Java的实体类对象
关系：关系型数据库
映射：二者之间的对应关系

![image-20220717150725726](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220717150725726.png)

> 1、映射文件的命名规则：
> 表所对应的实体类的类名+Mapper.xml
> 例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml
> 因此一个映射文件对应一个实体类，对应一张表的操作
> MyBatis映射文件用于编写SQL，访问以及操作表中的数据
> MyBatis映射文件存放的位置是src/main/resources/mappers目录下
> 2、MyBatis中可以面向接口操作数据，要保证两个一致：
> a>mapper接口的全类名和映射文件的命名空间（namespace）保持一致
> b>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.ep.mapper.UserMapper">
    <!--int insertUser();-->
    <insert id="insertUser">
        insert into user values(null,'张三','123',23,'女')
    </insert>
</mapper>
```

![image-20220717151303606](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220717151303606.png)

### 1.6通过junit测试功能

```java
//读取MyBatis的核心配置文件
        InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
        
        //创建SqlSessionFactoryBuilder对象
        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
        
        //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象
        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
        
        //创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务
        //SqlSession sqlSession = sqlSessionFactory.openSession();
        //创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        
        //通过代理模式创建UserMapper接口的代理实现类对象
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配
       // 映射文件中的SQL标签，并执行标签中的SQL语句
        int result = userMapper.insertUser();
        //sqlSession.commit();
        System.out.println("结果："+result);
```

### 1.7加入log4j日志功能

a>加入依赖

```xml
        <!-- log4j日志 -->
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>
```

b>加入log4j的配置文件

> og4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">
    <appender name="STDOUT" class="org.apache.log4j.ConsoleAppender">
        <param name="Encoding" value="UTF-8" />
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern" value="%-5p %d{MM-dd HH:mm:ss,SSS}
%m (%F:%L) \n" />
        </layout>
    </appender>
    <logger name="java.sql">
        <level value="debug" />
    </logger>
    <logger name="org.apache.ibatis">
        <level value="info" />
    </logger>
    <root>
        <level value="debug" />
        <appender-ref ref="STDOUT" />
    </root>
</log4j:configuration>
```

> 日志的级别
> FATAL(致命)>ERROR(错误)>WARN(警告)>INFO(信息)>DEBUG(调试)
> 从左到右打印的内容越来越详细

```xml
    <!--
       查询功能的标签必须设置resultType或resultMap
       resultType：设置默认的映射关系
       resultMap：设置自定义的映射关系
   -->
    <!--List<User> queryAllUser();-->
    <select id="queryAllUser" resultType="com.ep.pojo.User">
        select * from user
    </select>
```

## 2.核心配置文件详解

核心配置文件中的标签必须按照固定的顺序：
properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorF
actory?,plugins?,environments?,databaseIdProvider?,mappers?

mabatis-config.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>

    <!--
        MyBatis核心配置文件中，标签的顺序：
        properties?,settings?,typeAliases?,typeHandlers?,
        objectFactory?,objectWrapperFactory?,reflectorFactory?,
        plugins?,environments?,databaseIdProvider?,mappers?
    -->

    <!--引入properties文件-->
    <properties resource="jdbc.properties" />

    <!--设置类型别名-->
    <typeAliases>
        <!--
            typeAlias：设置某个类型的别名
            属性：
                type：设置需要设置别名的类型
                alias：设置某个类型的别名，若不设置该属性，那么该类型拥有默认的别名，即类名且不区分大小写
        -->
        <!--<typeAlias type="com.ep.pojo.User"></typeAlias>-->
        <!--以包为单位，将包下所有的类型设置默认的类型别名，即类名且不区分大小写-->
        <package name="com.ep.pojo"/>
    </typeAliases>

    <!--
        environments：配置多个连接数据库的环境
        属性：
            default：设置默认使用的环境的id
    -->
    <environments default="development">
        <!--
            environment：配置某个具体的环境
            属性：
                id：表示连接数据库的环境的唯一标识，不能重复
        -->
        <environment id="development">
            <!--
                transactionManager：设置事务管理方式
                属性：
                    type="JDBC|MANAGED"
                    JDBC：表示当前环境中，执行SQL时，使用的是JDBC中原生的事务管理方式，事务的提交或回滚需要手动处理
                    MANAGED：被管理，例如Spring
            -->
            <transactionManager type="JDBC"/>
            <!--
                dataSource：配置数据源
                属性：
                    type：设置数据源的类型
                    type="POOLED|UNPOOLED|JNDI"
                    POOLED：表示使用数据库连接池缓存数据库连接
                    UNPOOLED：表示不使用数据库连接池
                    JNDI：表示使用上下文中的数据源
            -->
            <dataSource type="POOLED">
                <!--设置连接数据库的驱动-->
                <property name="driver" value="${jdbc.driver}"/>
                <!--设置连接数据库的连接地址-->
                <property name="url" value="${jdbc.url}"/>
                <!--设置连接数据库的用户名-->
                <property name="username" value="${jdbc.username}"/>
                <!--设置连接数据库的密码-->
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>

        <environment id="test">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/mybatis"/>
                <property name="username" value="root"/>
                <property name="password" value="root"/>
            </dataSource>
        </environment>
    </environments>
    <!--引入映射文件-->
    <mappers>
        <!--<mapper resource="mappers/UserMapper.xml"/>-->
        <!--
            以包为单位引入映射文件
            要求：
            1、mapper接口所在的包要和映射文件所在的包一致
            2、mapper接口要和映射文件的名字一致
        -->
        <package name="com.ep.mapper"/>
    </mappers>
</configuration>
```

jdbc.properties

```properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8
jdbc.username=root
jdbc.password=root
```

## 3.MyBatis的增删改查

1、添加

```xml
    <!--int insertUser();-->
    <insert id="insertUser">
        insert into user values(null,'张三','123',23,'女',null)
    </insert>
```

2、删除

```xml
    <!--int deleteUser();-->
    <delete id="deleteUser">
        delete from user where id = 2
    </delete>
```

3、修改

```xml
    <!--int updateUser();-->
    <update id="updateUser">
        update user set email = "123456@qq.com" where id = 1
    </update>
```

4、查询一个实体类对象

```xml
<!--User getUserById();-->
<select id="getUserById" 	resultType="com.ep.bean.User">
	select * from t_user where id = 2
</select>
```

5、查询集合

```xml
    <!--List<User> queryAllUser();-->
    <select id="queryAllUser" resultType="user">
        select * from user
    </select>
```

> 注意：
> 1、查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射
> 关系
> resultType：自动映射，用于属性名和表中字段名一致的情况
> resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况
> 2、当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常
> TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值

## 4.MyBatis获取参数值的两种方式（重点）

MyBatis获取参数值的两种方式：``${}``和``#{}``
${}的本质就是字符串拼接(**没有引号，需要手动加**)，#{}的本质就是占位符赋值（**有引号**）
${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号

### 4.1单个字面量类型的参数

若mapper接口中的方法参数为单个的字面量类型
此时可以使用${}和#{}以**任意的名称**获取参数的值，注意**${}需要手动加单引号**

```xml
    <!--User getUserByUsername(String username);-->
    <select id="getUserByUsername" resultType="user">
        <!-- select * from user where username = #{username} -->
        <!-- 使用${} 要使用单引号 -->
        select * from user where username = '${username}'
    </select>
```

### 4.2多个字面量类型的参数

若mapper接口中的方法参数为多个时
此时MyBatis会自动将这些参数放在一个map集合中，**以arg0,arg1...为键，以参数为值**；

**以param1,param2...为键，以参数为值**；

因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号

![image-20220717213318093](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220717213318093.png)

```xml
    <!--String checkLogin(String username, String password);-->
    <select id="checkLogin" resultType="user">
        <!--select * from user where username = #{arg0} and password = #{arg1}-->
        <!--select * from user where username = #{param1} and password = #{param2}-->
        <!--select * from user where username = #{arg0} and password = #{param2}-->
        select * from user where username = '${arg0}' and password = '${param2}'
    </select>
```

### 4.3map集合类型的参数

若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中
只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意**${}需要手动加单引号**

```xml
    <!--User checkLoginByMap(Map<String, Object> map);-->
    <select id="checkLoginByMap" resultType="user">
        <!--select * from user where username = '${username}' and password = '${password}'-->
        select * from user where username = #{username} and password = #{password}
    </select>
```

```java
HashMap<String, Object> hashMap = new HashMap<String, Object>();
        hashMap.put("username","admin");
        hashMap.put("password","123");
```

### 4.4实体类类型的参数

若mapper接口中的方法参数为实体类对象时
此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意**${}需要手动加单引号**

```xml
    <!--User ckeckLoginByUser(User user);-->
    <select id="ckeckLoginByUser" resultType="user">
        <!--select * from user where username = '${username}' and password = '${password}'-->
        select * from user where username = #{username} and password = #{password}
    </select>
```

### 4.5使用@Param标识参数

可以通过@Param注解标识mapper接口中的方法参数
此时，会将这些参数放在map集合中，以@Param注解的value属性值为键，(@Param(value="username")可以省略value)以参数为值；以param1,param2...为键，以参数为值；只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号

```xml
    <!--User checkLoginByParam(@Param("username") String username, @Param("password") String password);-->
    <select id="checkLoginByParam" resultType="user">
        select * from user where username = #{username} and password = #{password}
    </select>
```

## 5.MyBatis的各种查询功能

### 5.1查询一个实体类对象

```java
/**
* 根据用户id查询用户信息
* @param id
* @return
*/
User getUserById(@Param("id") int id);
```

```xml
    <!--User getUserById(@Param("id") int id);-->
    <select id="getUserById" resultType="user">
        select * from user where id = #{id}
    </select>
```

### 5.2查询一个list集合

```java
    /**
     * 查询所有用户信息
     * @return
     */
    List<User> getUserList();
```

```java
    <!--List<User> getUserList();-->
    <select id="getUserList" resultType="user">
        select * from user
    </select>
```

### 5.3查询单个数据

```java
    /**
     * 查询用户的总记录数
     * @return
     * 在MyBatis中，对于Java中常用的类型都设置了类型别名
     * 例如：java.lang.Integer-->int|integer
     * 例如：int-->_int|_integer
     * 例如：Map-->map,List-->list
     */
    int getCount();
```

```xml
    <!--int getCount();-->
    <select id="getCount" resultType="int">
        select count(*) from user
    </select>
```

![image-20220718102829826](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220718102829826.png)

![image-20220718102856023](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220718102856023.png)

### 5.4查询一条数据为map集合

```java
    /**
     * 根据用户id查询用户信息为map集合
     * @param id
     * @return
     */
    Map<String, Object> getUserToMap(@Param("id") int id);
```

```xml
    <!--Map<String, Object> getUserToMap(@Param("id") int id);-->
    <select id="getUserToMap" resultType="map">
        select * from user where id = #{id}
    </select>
{password=123, sex=女, id=1, age=23, email=123456@qq.com, username=张三}
```

### 5.5查询多条数据为map集合

方式一：

```java
    /**
     * 查询所有用户信息为map集合
     * @return
     * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此
    时可以将这些map放在一个list集合中获取
     */
    List<Map<String, Object>> getAllUserToMap();
```

```xml
    <!--List<Map<String, Object>> getAllUserToMap();-->
    <select id="getAllUserToMap" resultType="map">
        select * from user
    </select>
```

方式二：

```java
    /**
     * 查询所有用户信息为map集合
     * @return
     * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并
    且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的
    map集合
     */
    @MapKey("id")
    Map<String, Object> getAllUserToMap();
```

```xml
    <!--List<Map<String, Object>> getAllUserToMap();
    @MapKey("id")
    Map<String, Object> getAllUserToMap();
    -->
    <select id="getAllUserToMap" resultType="map">
        select * from user
    </select>
<!--
{
	1={password=123456, sex=男, id=1, age=23, username=admin},
	2={password=123456, sex=男, id=2, age=23, username=张三},
	3={password=123456, sex=男, id=3, age=23, username=张三}
}
-->
```

## 6.特殊SQL的执行

### 6.1模糊查询

```java
    /**
     * 测试模糊查询
     * @param query
     * @return
     */
    List<User> testMohu(@Param("query") String query);
```
推荐使用:`select * from user where username like "%"#{query}"%"`
**%这里要使用双引号**

```xml
    <!--List<User> testMohu(@Param("query") String query);-->
    <select id="testMohu" resultType="user">
        <!--select * from user where username like '%#{query}%'错误写法
        执行的SQL语句：select * from user where username like '%?%'-->

        <!--select * from user where username like '%${query}%'-->
        <!--select * from user where username like concat('%',#{query},'%')-->
        select * from user where username like "%"#{query}"%"
    </select>
```

### 6.2批量删除

```java
    /**
     * 批量删除
     * @param ids  "1,2,3"
     * @return
     */
    int deleteMore(@Param("ids") String ids);
```

```xml
    <!--int deleteMore(@Param("ids") String ids);-->
    <delete id="deleteMore">
        <!--delete from user where id in (#{ids})  不可以这样删除，因为内部是''拼接-->
        delete from user where id in (${ids})
    </delete>
```

### 6.3动态设置表名

```java
    /**
     * 动态设置表名，查询所有的用户信息
     * @param tableName
     * @return
     */
    List<User> getAllUser(@Param("tableName") String tableName);
```
**这里只能用${},**因为#{}会加引号，表名是不能加引号的

```xml
    <!--List<User> getAllUser(@Param("tableName") String tableName);-->
    <select id="getAllUser" resultType="user">
        select * from ${tableName}
    </select>
```

### 6.4添加功能获取自增的主键

```java
/**
* 添加用户信息
* @param user
* @return
* useGeneratedKeys：设置使用自增的主键
* keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参
数user对象的某个属性中
*/
int insertUser(User user);
```

会将新插入值的id返回

```xml
    <!--int insertUser(User user);-->
    <insert id="insertUser" useGeneratedKeys="true" keyProperty="id">
        insert into user values(null,#{username},#{password},#{age},#{sex},#{email})
    </insert>
```

## 7.自定义映射resultMap

解决字段名和属性名不一致的情况

方式1.为字段起别名，保持和属性名一致

```xml
 <!--List<Emp> findAllEmp();
    -->
    <select id="findAllEmp" resultType="emp">
        select eid,emp_name empName,age,email,sex from t_emp;
    </select>
```

方式2.设置全局配置，将_自动映射为驼峰

mybatis-config.xml

```xml
    <!--让_自动转化为驼峰，例如：emp_name转为empName-->
    <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>
```

方式3.通过resultMap处理映射关系

### 7.1resultMap处理字段和属性的映射关系

若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射

**property实体中的名字，column数据库表中的字段名**

**type:实体名**

**id：设置主键的映射关系**
**result：设置普通字段的映射关系**
**association：设置多对一的映射关系**
**collection：设置一对多的映射关系**

想要的数据都要写，否则获取不到

```xml
<!--
resultMap：设置自定义映射
属性：
id：表示自定义映射的唯一标识
type：查询的数据要映射的实体类的类型
子标签：
	id：设置主键的映射关系
	result：设置普通字段的映射关系
	association：设置多对一的映射关系
	collection：设置一对多的映射关系
属性：
	property：设置映射关系中实体类中的属性名
	column：设置映射关系中表中的字段名
-->
    <resultMap id="empResultMap" type="emp">
        <id property="eid" column="eid"></id>
        <result property="empName" column="emp_name"></result>
        <result property="age" column="age"></result>
        <result property="email" column="email"></result>
        <result property="sex" column="sex"></result>
    </resultMap>

    <!--List<Emp> findAllEmp();-->
    <select id="findAllEmp" resultMap="empResultMap">
        select * from t_emp;
    </select>
```

> 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则
> 此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系
> a>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致
> b>可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可
> 以在查询表中数据时，自动将_类型的字段名转换为驼峰
> 例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为
> userName

### 7.2多对一映射处理

> 查询员工信息以及员工所对应的部门信息

#### 7.2.1.级联方式处理映射关系

```xml
 <resultMap id="empResultMapOne" type="emp">
        <id property="eid" column="eid"></id>
        <result property="empName" column="emp_name"></result>
        <result property="age" column="age"></result>
        <result property="email" column="email"></result>
        <result property="sex" column="sex"></result>
        <result property="dept.did" column="did"></result>
        <result property="dept.deptName" column="dept_name"></result>
    </resultMap>

    <!--Emp findEmpOne(@Param("id") int id);-->
    <select id="findEmpOne" resultMap="empResultMapOne">
        select * from t_emp left join t_dept on t_emp.did = t_dept.did where t_emp.eid = #{id}
    </select>
```

#### ![image-20220718155338822](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220718155338822.png)7.2.2.使用association处理映射关系

**Dept为java实体**， **property为emp实体中的属性名**

```xml
<resultMap id="empResultMapTwo" type="emp">
        <id property="eid" column="eid"></id>
        <result property="empName" column="emp_name"></result>
        <result property="age" column="age"></result>
        <result property="email" column="email"></result>
        <result property="sex" column="sex"></result>
        <association property="dept" javaType="Dept">
            <id property="did" column="did"></id>
            <result property="deptName" column="dept_name"></result>
        </association>
    </resultMap>

    <!--Emp findEmpOne(@Param("id") int id);-->
    <select id="findEmpOne" resultMap="empResultMapTwo">
        select * from t_emp left join t_dept on t_emp.did = t_dept.did where t_emp.eid = #{id}
    </select>
```

#### 7.2.3.分步查询

1）查询员工信息

```java
/*
    * 分布查询获取员工的信息以及部门信息
    * 1.获取员工信息
    * */
    Emp findEmpOneByStepOne(@Param("id") String id);
```

```xml
    <resultMap id="empResultMapStepOne" type="emp">
        <id property="eid" column="eid"></id>
        <result property="empName" column="emp_name"></result>
        <result property="age" column="age"></result>
        <result property="email" column="email"></result>
        <result property="sex" column="sex"></result>
        <!--
        select：设置分步查询，查询某个属性的值的sql的标识（namespace.sqlId）
        column：将sql以及查询结果中的某个字段设置为分步查询的条件
        -->
        <association property="dept"  select="com.ep.mapper.DeptMapper.findDeptOne" column="did">
		
        </association>
    </resultMap>
    <!--Emp findEmpOneByStepOne(@Param("id") int id);-->
    <select id="findEmpOneByStepOne" resultMap="empResultMapStepOne">
        select * from t_emp where t_emp.eid = #{id}
    </select>
```

2）根据员工所对应的部门id查询部门信息

```java
    /*
     * 分布查询获取员工的信息以及部门信息
     * 2.根据员工信息的返回值获取部门信息
     * */
    Dept findDeptOne(@Param("id") int id);
```

```xml
    <resultMap id="DeptResultMap" type="dept">
        <id property="did" column="did"></id>
        <result property="deptName" column="dept_name"></result>
    </resultMap>

    <!--Dept findDeptOne(@Param("id") int id);-->
    <select id="findDeptOne" resultMap="DeptResultMap">
        select * from t_dept where did = #{id}
    </select>
```

### 7.3一对多映射处理

#### 7.3.1collection

![image-20220718172000198](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220718172000198.png)



```java
	 /*
    * 根据部门id查询部门的员工信息
    * */
    List<Dept> findAllDept(@Param("id") int id);
```
**ofType：设置collection标签所处理的集合属性中存储数据的类型**

```xml
 <resultMap id="DeptsResultMap" type="dept">
        <id property="did" column="did"></id>
        <result property="deptName" column="dept_name"></result>
        <collection property="emps" ofType="Emp">
            <id property="eid" column="eid"></id>
            <result property="empName" column="empName"></result>
            <result property="sex" column="sex"></result>
            <result property="age" column="age"></result>
            <result property="email" column="email"></result>
        </collection>
    </resultMap>

    <!--List<Dept> findAllDept(@Param("id") int id);-->
    <select id="findAllDept" resultMap="DeptsResultMap">
        select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #{id}
    </select>
```

#### 7.3.2分步查询

1)查询部门的信息

```java
    /*
    * 一对多分布查询，部门以及部门成员
    * 1.查询部门信息
    * */
    Dept findDeptByStepOne(@Param("id") int id);
```

```xml
    <resultMap id="deptResultMapByStep" type="dept">
        <id property="did" column="did"></id>
        <result property="deptName" column="dept_name"></result>
        <!--一对多分布查询-->
        <collection property="emps" select="com.ep.mapper.EmpMapper.findDeptByStepTwo" column="did">

        </collection>
    </resultMap>

    <!--一对多分部查询第一步：Dept findDeptByStepOne(@Param("id") int id);-->
    <select id="findDeptByStepOne" resultMap="deptResultMapByStep">
        select * from t_dept where did = #{id}
    </select>
```

2）根据部门信息返回的did查询部门成员的信息

```java
 /*
     * 一对多分布查询，部门以及部门成员
     * 2 查询部门成员信息
     * */
    List<Emp>  findDeptByStepTwo(@Param("did") int did);
```

```xml
 <!--List<Emp>  findDeptByStepTwo(@Param("did") int did);
        这里可以直接引入emp，是因为在mybatis-config.xml配置了 <setting name="mapUnderscoreToCamelCase" value="true"/>
        自动转换为驼峰
    -->
    <select id="findDeptByStepTwo" resultType="emp">
        select * from t_emp where did = #{did};
    </select>
```

> 分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：
> lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载
> aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载
> 此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType="lazy(延迟加载)|eager(立即加载)"

mybatis-config.xml
```xml
 <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
        <!--开启全局延迟加载-->
        <setting name="lazyLoadingEnabled" value="true"/>
 </settings>
```

开启全局延迟加载后，如果想要获取员工的个人信息，则不会去查询所属部门的信息

![image-20220718170633591](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220718170633591.png)

![image-20220718171049010](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220718171049010.png)

## 8.动态SQL

Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题。

### 8.1 if

if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中
的内容不会执行(if条件满足，语句才会被拼接)

```xml
<!--List<Emp> getEmpByDynamicSql(Emp emp);-->
    <select id="getEmpByDynamicSql" resultType="emp">
        select * from t_emp where 1 = 1
        <if test="empName != null and empName !=''">
             and emp_name = #{empName}
        </if>
        <if test="sex != null and sex != ''">
            and sex = #{sex}
        </if>
        <if test="age != null and age != ''">
            and age = #{age}
        </if>
    </select>
```

### 8.2where

**where只能去掉前面的and或者or**

```xml
    <!--List<Emp> getEmpByDynamicSql(Emp emp);-->
    <select id="getEmpByDynamicSql" resultType="emp">
        select * from t_emp
        <where>
            <if test="empName != null and empName !=''">
                 and emp_name = #{empName}
            </if>
            <if test="sex != null and sex != ''">
                or sex = #{sex}
            </if>
            <if test="age != null and age != ''">
                and age = #{age}
            </if>
        </where>
    </select>
```

> where和if一般结合使用：
> a>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字
> b>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and去掉
> 注意：where标签不能去掉条件最后多余的and

### 8.3trim

```xml
<!--List<Emp> getEmpByDynamicSql(Emp emp);-->
    <select id="getEmpByDynamicSql" resultType="emp">
        select * from t_emp
        <trim prefix="where" prefixOverrides="and|or">
            <if test="empName != null and empName !=''">
                emp_name = #{empName} and
            </if>
            <if test="sex != null and sex != ''">
                 sex = #{sex}
            </if>
            <if test="age != null and age != ''">
                age = #{age}
            </if>
        </trim>
    </select>
```

> trim用于去掉或添加标签中的内容
> 常用属性：
> prefix：在trim标签中的内容的前面添加某些内容
> prefixOverrides：在trim标签中的内容的前面去掉某些内容
> suffix：在trim标签中的内容的后面添加某些内容
> suffixOverrides：在trim标签中的内容的后面去掉某些内容

### 8.4choose、when、otherwise

choose、when、otherwise相当于if...else if..else

when至少有一个，otherwise至多有一个

只会执行一个

```xml
 <!--List<Emp> getEmpByDynamicSql(Emp emp);-->
    <select id="getEmpByDynamicSql" resultType="emp">
        select * from t_emp
        <where>
            <choose>
                <when test="empName != null and empName !=''">
                    emp_name = #{empName}
                </when>
                <when test="sex != null and sex != ''">
                    sex = #{sex}
                </when>
                <when test="age != null and age != ''">
                    age = #{age}
                </when>
                <otherwise>
                    did = 1
                </otherwise>
            </choose>
        </where>
    </select>
```



### 8.5 foreach

两种方法删除

```java
new Integer[]{6, 7, 8, 9,10,11}
```

```xml
    <!--int deleteMoreEmp(@Param("eids") Integer[] eids);-->
    <delete id="deleteMoreEmp">
<!--        delete from t_emp where eid in-->
<!--        <foreach collection="eids" separator="," item="eid" open="(" close=")">-->
<!--            #{eid}-->
<!--        </foreach>-->
        delete from t_emp where
        <foreach collection="eids" item="eid" separator="or">
            eid = #{eid}
        </foreach>
    </delete>
```

> 属性：
> collection：设置要循环的数组或集合
> item：表示集合或数组中的每一个数据
> separator：设置循环体之间的分隔符
> open：设置foreach标签中的内容的开始符
> close：设置foreach标签中的内容的结束符

批量添加员工

```java
  Emp emp1 = new Emp(0,"a","18","123456@qq.com","男",null);
  Emp emp2 = new Emp(0,"b","18","123456@qq.com","男",null);
  Emp emp3 = new Emp(0,"c","18","123456@qq.com","男",null);
  List<Emp> emps = Arrays.asList(emp1,emp2,emp3);
```

```xml
  <!--int insertMoreEmp(@Param("emps") List<Emp> emps);-->
    <insert id="insertMoreEmp">
        insert into t_emp values
        <foreach collection="emps" separator="," item="emp">
            (null,#{emp.empName},#{emp.age},#{emp.sex},#{emp.email},null)
        </foreach>
    </insert>
```

### 8.6SQL片段

sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入

```xml
<sql id="empColumns">
	eid,ename,age,sex,did
</sql>
select <include refid="empColumns"></include> from t_emp
```

## 9.MyBatis的缓存

### 9.1MyBatis的一级缓存

一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问.``一级缓存是默认开启的`

**使一级缓存失效的四种情况：**

*  不同的SqlSession对应不同的一级缓存
*  同一个SqlSession但是查询条件不同
* 同一个SqlSession两次查询期间执行了任何一次增删改操作
*  同一个SqlSession两次查询期间手动清空了缓存

### 9.2MyBatis的二级缓存

二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取

**二级缓存开启的条件：**
a>在核心配置文件中，设置全局配置属性``cacheEnabled="true"``，**默认为true，不需要设置**
b>在映射文件中设置标签``<cache/>``

c>二级缓存必须在SqlSession关闭或提交之后有效
d>查询的数据所转换的实体类类型**必须实现序列化的接口**

![image-20220719090501947](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220719090501947.png)

![image-20220719090952596](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220719090952596.png)

**使二级缓存失效的情况：**
两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效

### 9.3二级缓存的相关配置

在mapper配置文件中添加的cache标签可以设置一些属性：

* eviction属性：缓存回收策略
  * LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。
  * FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。
  * SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。
  * WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。
    默认的是 LRU。
* flushInterval属性：刷新间隔，单位毫秒
  * 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新
* size属性：引用数目，正整数
  * 代表缓存最多可以存储多少个对象，太大容易导致内存溢出
* readOnly属性：只读，true/false
  * true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了
    很重要的性能优势。
  * false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。

### 9.4MyBatis缓存查询的顺序

先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。
如果二级缓存没有命中，再查询一级缓存
如果一级缓存也没有命中，则查询数据库
SqlSession关闭之后，一级缓存中的数据会写入二级缓存

### 9.5整合第三方缓存EHCache

**a>添加依赖**

mybatis核心，junit测试，log4j,mysql的包也要导入（不过log4j已经没用了)

```xml
<!-- Mybatis EHCache整合包 -->
<dependency>
	<groupId>org.mybatis.caches</groupId>
	<artifactId>mybatis-ehcache</artifactId>
	<version>1.2.1</version>
</dependency>
<!-- slf4j日志门面的一个具体实现 -->
<dependency>
	<groupId>ch.qos.logback</groupId>
	<artifactId>logback-classic</artifactId>
	<version>1.2.3</version>
</dependency>
```

**b>各jar包功能**

![image-20220719091532790](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220719091532790.png)

**c>创建EHCache的配置文件ehcache.xml**

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="../config/ehcache.xsd">
    <!-- 磁盘保存路径 -->
    <diskStore path="D:\atguigu\ehcache"/>
    <defaultCache
            maxElementsInMemory="1000"
            maxElementsOnDisk="10000000"
            eternal="false"
            overflowToDisk="true"
            timeToIdleSeconds="120"
            timeToLiveSeconds="120"
            diskExpiryThreadIntervalSeconds="120"
            memoryStoreEvictionPolicy="LRU">
    </defaultCache>
</ehcache>
```

**d>设置二级缓存的类型**

```xml
<cache type="org.mybatis.caches.ehcache.EhcacheCache"/>
```

**e>加入logback日志**

存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。
创建logback的配置文件logback.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration debug="true">
    <!-- 指定日志输出的位置 -->
    <appender name="STDOUT"
              class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
             <!-- 日志输出的格式 -->
             <!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 -->
             <pattern>[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger] [%msg]%n</pattern>
         </encoder>
    </appender>
    <!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR -->
    <!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 -->
    <root level="DEBUG">
        <!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender -->
        <appender-ref ref="STDOUT" />
    </root>
    <!-- 根据特殊需求指定局部日志级别 -->
    <logger name="com.atguigu.crowd.mapper" level="DEBUG"/>
</configuration>
```

**f>EHCache配置文件说明**

![image-20220719092436814](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220719092436814.png)

## 10.MyBatis的逆向工程

* 正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的。
* 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：
  * Java实体类
  * Mapper接口
  * Mapper映射文件

### 10.1创建逆向工程的步骤

**a>添加依赖和插件**

```xml
    <!-- 依赖MyBatis核心包 -->
    <dependencies>
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.7</version>
        </dependency>
    </dependencies>
    <!-- 控制Maven在构建过程中相关配置 -->
    <build>
        <!-- 构建过程中用到的插件 -->
        <plugins>
            <!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 -->
            <plugin>
                <groupId>org.mybatis.generator</groupId>
                <artifactId>mybatis-generator-maven-plugin</artifactId>
                <version>1.3.0</version>
                <!-- 插件的依赖 -->
                <dependencies>
                    <!-- 逆向工程的核心依赖 -->
                    <dependency>
                        <groupId>org.mybatis.generator</groupId>
                        <artifactId>mybatis-generator-core</artifactId>
                        <version>1.3.2</version>
                    </dependency>
                    <!-- 数据库连接池 -->
                    <dependency>
                        <groupId>com.mchange</groupId>
                        <artifactId>c3p0</artifactId>
                        <version>0.9.2</version>
                    </dependency>
                    <!-- MySQL驱动 -->
                    <dependency>
                        <groupId>mysql</groupId>
                        <artifactId>mysql-connector-java</artifactId>
                        <version>5.1.8</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>

```

**b>创建MyBatis的核心配置文件**

**c>创建逆向工程的配置文件**

配置里面的内容需要自行更改

> 文件名必须是：generatorConfig.xml 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <!--
        targetRuntime: 执行生成的逆向工程的版本
        MyBatis3Simple: 生成基本的CRUD（清新简洁版）
        MyBatis3: 生成带条件的CRUD（奢华尊享版）
        -->
    <context id="DB2Tables" targetRuntime="MyBatis3Simple">
        <!-- 数据库的连接信息 -->
        <jdbcConnection driverClass="com.mysql.jdbc.Driver"
                        connectionURL="jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8"
                        userId="root"
                        password="root">
        </jdbcConnection>
        <!-- javaBean的生成策略-->
        <javaModelGenerator targetPackage="com.ep.pojo"
                            targetProject=".\src\main\java">
            <property name="enableSubPackages" value="true" />
            <property name="trimStrings" value="true" />
        </javaModelGenerator>
        <!-- SQL映射文件的生成策略 -->
        <sqlMapGenerator targetPackage="com.ep.mapper"
                         targetProject=".\src\main\resources">
            <property name="enableSubPackages" value="true" />
        </sqlMapGenerator>
        <!-- Mapper接口的生成策略 -->
        <javaClientGenerator type="XMLMAPPER"
                             targetPackage="com.ep.mapper" targetProject=".\src\main\java">
            <property name="enableSubPackages" value="true" />
        </javaClientGenerator>
        <!-- 逆向分析的表 -->
        <!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName -->
        <!-- domainObjectName属性指定生成出来的实体类的类名 -->
        <table tableName="t_emp" domainObjectName="Emp"/>
        <table tableName="t_dept" domainObjectName="Dept"/>
    </context>
</generatorConfiguration>
```

**d>执行MBG插件的generate目标**

![image-20220719102053831](https://trpora-1300527744.cos.ap-chongqing.myqcloud.com/img/image-20220719102053831.png)

**最后生成代码之后，记得配置mybatis-config.xml里面的类型别名和映射文件**

### 10.2QBC查询

```java
 @Test
    public void testMBG() throws IOException {
        InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
        SqlSession sqlSession = new
                SqlSessionFactoryBuilder().build(is).openSession(true);
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        // 查询所有
//        List<Emp> emps = mapper.selectByExample(null);
//        System.out.println(emps);

        //条件查找
        //创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系
//        EmpExample empExample = new EmpExample();
//        empExample.createCriteria().andDidEqualTo(2).andAgeGreaterThan(20);
//        //将之前添加的条件通过or拼接其他条件
//        empExample.or().andEmailEqualTo("123@qq.com");
//        List<Emp> emps = mapper.selectByExample(empExample);
//        System.out.println(emps);

        // 添加
       // mapper.insert(new Emp(null,"insert",18,"男","123@qq.com",2));
        // 条件添加
        //mapper.insertSelective(new Emp(null,"insert",18,null,"123@qq.com",2));

        // 修改
        EmpExample empExample = new EmpExample();
       // mapper.updateByPrimaryKey(new Emp(12,"insert",18,"男","123@qq.com",2));
        mapper.updateByPrimaryKey(new Emp(12,"insert2",null,null,"123456789@qq.com",2));
    }
```

## 11.分页插件

### 11.1分页插件使用步骤

**a>添加依赖**

```xml
        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper</artifactId>
            <version>5.2.0</version>
        </dependency>
```

**b>配置分页插件**
在MyBatis的核心配置文件中配置插件

```xml
<plugins>
	<!--设置分页插件-->
	<plugin interceptor="com.github.pagehelper.PageInterceptor"></plugin>
</plugins>
```

### 11.2分页插件的使用

a>在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能

> pageNum：当前页的页码
> pageSize：每页显示的条数

b>在查询获取list集合之后，使用``PageInfo<T> pageInfo = new PageInfo<>(List<T> list, intnavigatePages)``获取分页相关数据

> list：分页之后的数据
> navigatePages：导航分页的页码数

c>分页相关数据

> PageInfo{
> pageNum=8, pageSize=4, size=2, startRow=29, endRow=30, total=30, pages=8,
> list=Page{count=true, pageNum=8, pageSize=4, startRow=28, endRow=32, total=30,
> pages=8, reasonable=false, pageSizeZero=false},
> prePage=7, nextPage=0, isFirstPage=false, isLastPage=true, hasPreviousPage=true,
> hasNextPage=false, navigatePages=5, navigateFirstPage4, navigateLastPage8,
> navigatepageNums=[4, 5, 6, 7, 8]
> }

常用数据：

> pageNum：当前页的页码
> pageSize：每页显示的条数
> size：当前页显示的真实条数
> total：总记录数
> pages：总页数
> prePage：上一页的页码
> nextPage：下一页的页码
> isFirstPage/isLastPage：是否为第一页/最后一页
> hasPreviousPage/hasNextPage：是否存在上一页/下一页
> navigatePages：导航分页的页码数
> navigatepageNums：导航分页的页码，[1,2,3,4,5]

```java
 /*
    * 分页插件的使用
    * */
    @Test
    public void testPage() throws IOException {
        InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
        SqlSession sqlSession = new
                SqlSessionFactoryBuilder().build(is).openSession(true);
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        //Page<Object> objects = PageHelper.startPage(1, 5);
        PageHelper.startPage(1,5);
        List<Emp> emps = mapper.selectByExample(null);
        PageInfo<Emp> empPageInfo = new PageInfo<>(emps, 5);
        //System.out.println(objects);
        emps.forEach(emp -> System.out.println(emp));
        System.out.println(empPageInfo);
    }
```

